= Rust Strings, Explained

== Introduction to &str and String

Rust has two main types of strings: `&str` and `String`.

[code,rust]
----
use std::net::TcpStream;

let addr = "127.0.0.1"; // this is a &str, a &'static str to be specific
let mut addr_str = slice.to_string(); // this is a String
let addr2 = &slice; // coerce back to a &str

TcpStream::connect(addr); // no problem
TcpStream::connect(&*addr_string); // no automatic coercion to traits of &str
----

This string `addr`, also known as a 'string slice', is statically allocated, meaning that itâ€™s saved inside our compiled program, and exists for the entire duration it runs. The greeting binding is a reference to this statically allocated string. String slices have a fixed size, and cannot be mutated.

A `String` like `addr_str`, on the other hand, is a heap-allocated string. This string is growable, and is also guaranteed to be UTF-8. Strings are commonly created by converting from a string slice using the `to_string` method.

To coerce a `String` into a `&str`, you can use `&`, unless the destination type is a trait of &str, in which case you need to use `&*`.


== Should my function take a String, a &str, or one of the traits of &str?

Naturally, be as specific as possible when choosing between `&str` or one of the traits of `&str`.  The stdlib example above from link:https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.connect[TcpStream::connect] is a great example

When choosing between `&str` and `String`, choose `&str` **virtually every time**.  Viewing a String as a &str is cheap, but converting the &str to a String involves allocating memory. No reason to do that unless you have to!

If you are coming from a JVM-based language, actively fight the urge to write to `String` types.

== Should my struct contain a String or a &str?

???

== Splitting

Explain how array destructuring is a more optimal solution, but is currently in nightly and has been for two years...

[code,rust]
----
pub struct Dependency {
    org: String,
    name: String,
    rev: String
}

pub fn parse_dependency(dep: &str) -> Result<Dependency, String> {
    let dp = dep.split(':').collect::<Vec<&str>>();
    return match dp.len() {
        3 => Ok(Dependency { org: dp[0].to_string(), name: dp[1].to_string(), rev: dp[2].to_string() }),
        _ => Err("--dependency must be in the format org:name:rev".to_string())
    };
}

----

Explain how the manual cast to Vec<&str> is suboptimal because collect could return any other basic collection type.  Need it for `len()` though?